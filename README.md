#### 学号：ZF2221515
#### 姓名：张静     
#### 《程序设计与算法》大作业队伍：静姐的背包

* 本次代码主要是排序算法：
选择排序，归并排序，快速排序，希尔排序，基数排序，
对所有算法进行分析并实现，分析其在不同规模的输入下单机性能变化情况；
* 利用多线程实现大规模数据的分布式排序，输入超过100万为最低大规模要求。
* 关于下面所有排序取大值随机数，都会使用以下方式

  用rand函数生成-10的100次方至10的100次方的随机数，并赋值给数组a[i],
  使用arr[i] = ((rand () % (b - a + 1)) + a)
  这种方式方式取值会有问题，导致概率不均，所以按照拼接成大数的方式来获取大数随机数
```C++
for(i = 1;i < maxSize; i++) {
    // 用rand函数生成-10的100次方至10的100次方的随机数，并赋值给数组a[i]
    // arr[i] = ((rand () % (b - a + 1)) + a);
    // todo：此处大数随机数按照上面的方式取值会有问题，导致概率不均，所以按照拼接成大数的方式来获取大数随机数
    arr[i] = (rand()<<30) + (rand()<<30) + (rand()<<15) + rand();
}
```

### 一、选择排序
##### 选择排序的代码思想 
每次都从未排序的序列中选择一个最小的数放在已排序列的最左边，直至排序完成。

```C++
// 算法核心代码
for(i = 1; i < n; i++) { // 共作n-1趟选择排序
    pos = i; // 保存最小数的位置
    for(j = i; j <= n; j++) { // 找比arr[i]更小的值
        if(arr[j] < arr[pos]) {
            pos = j; // 指向更小的数的位置
        }
    }
    if(pos != i) { // 找到了更小的值，就交换位置
        arr[0] = arr[i]; // arr[0]作为暂存单元
        arr[i] = arr[pos];
        arr[pos] = arr[0];
    }
}
```

##### 选择排序算法执行结果
1、选择排序10个数(范围是-10的100次方～10的100次方)所花费的时间0.000100416s

![排序10个数](/image/selectSort10.jpg)

2、选择排序100个数(范围是-10的100次方～10的100次方)所花费的时间0.00333846s

![排序100个数](/image/selectSort100.jpg)

3、选择排序1000个数(范围是-10的100次方～10的100次方)所花费的时间0.0824305s
(由于排序数目过多就不截图排序后的及结果)

![排序1000个数](/image/selectSort1000.jpg)

4、选择排序1w个数(范围是-10的100次方～10的100次方)所花费的时间0.794108s
(由于排序数目过多就不截图排序后的及结果)

![排序1w个数](/image/selectSort1w.jpg)

5、选择排序10w个数(范围是-10的100次方～10的100次方)所花费的时间12.2725s
(由于排序数目过多就不截图排序后的及结果)

![排序10w个数](/image/selectSort10w.jpg)

6、选择排序10w个数(范围是-10的100次方～10的100次方)所花费的时间578.437s
(由于排序数目过多就不截图排序后的及结果)

![排序100w个数](/image/selectSort100w.jpg)

##### 选择排序的算法分析
选择排序的复杂度分析。第一次内循环比较N - 1次，然后是N-2次，N-3次，……，最后一次内循环比较1次。
共比较的次数是 (N - 1) + (N - 2) + ... + 1，求等差数列和，得 (N - 1 + 1)* N / 2 = N^2 / 2。
舍去最高项系数，其时间复杂度为 O(N^2)。

### 二、归并排序
##### 归并排序的代码思想 
归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）

分治模式在每一层递归上有三个步骤：

分解（Divide）：将n个元素分成个含n/2个元素的子序列。

解决（Conquer）：用合并排序法对两个子序列递归的排序。

合并（Combine）：合并两个已排序的子序列已得到排序结果。

![mergeSort](/image/mergeSort.png)

```C++
// 归并算法核心代码

```

##### 归并排序算法执行结果
1、归并排序10个数(范围是-10的100次方～10的100次方)所花费的时间0.0001285s

![排序10个数](/image/selectSort10.jpg)

2、归并排序100个数(范围是-10的100次方～10的100次方)所花费的时间0.00317862s

![排序100个数](/image/selectSort100.jpg)

3、归并排序1000个数(范围是-10的100次方～10的100次方)所花费的时间0.0801555s
(由于排序数目过多就不截图排序后的及结果)

![排序1000个数](/image/selectSort1000.jpg)

4、归并排序1w个数(范围是-10的100次方～10的100次方)所花费的时间0.780275s
(由于排序数目过多就不截图排序后的及结果)

![排序1w个数](/image/selectSort1w.jpg)

5、归并排序10w个数(范围是-10的100次方～10的100次方)所花费的时间8.00069s
(由于排序数目过多就不截图排序后的及结果)

![排序10w个数](/image/selectSort10w.jpg)

6、归并排序10w个数(范围是-10的100次方～10的100次方)所花费的时间76.4242s
(由于排序数目过多就不截图排序后的及结果)

![排序100w个数](/image/selectSort100w.jpg)

##### 归并排序的算法分析






